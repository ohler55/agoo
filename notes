;; -*- mode: outline; outline-regexp: " *[-\+]"; indent-tabs-mode: nil; fill-column: 120 -*-

todo
-----------

- graphql
 - validation

 - subscription
  - server.c
   - why is res not getting put on queue
    - probably ned a lock or use a queue

  - then eval doc to get the string

  - when req received
   - parse doc
   - call ruby to get subject gqleval.c 467
   - create a new gqlSub
    - place on list, use mutex
   - on gql_new_event
    - walk list and find matches
     - if a match then eval doc against event value
     - add response to con res list
    - should this be done in thread that does the adding or is another queue and thread needed
     - initially use the calling thread
     - or alternaitve is add to event queue or use eval_queue

  - eval of event must be with gvl since it is ruby
   - to use thegvl

  - create gqlSub and gqlEvent

  - on subscribe
   - eval code to determine subject, that is the filter
   - create gqlSub
  - on event create
   - create a gqlValue
    - put on pub_queue
   - members
    - ref cnt
    - gqlValue
    - subject
  - processing
   - eval against all subscriptions - like publish_pub() in con.c
   - which is better, load on ruby side or con write side?
    - or separate eval thread for publishing?
    - could it be configurable?
     - keep sub eval cleanly separate

 - unsubcribe
  - just close connection

  - add hook to handle writes


  - return code same as websocket or sse return (upgrade)
   - return 426 if no upgrade in request
   - return 101 for upgrade?

  - subscribe resolve func should return subject to listen on
  - eval for subscribe must be one level but gather test for filter

  - pub.[ch]
   - add field for gqlValue
   - add type for GQL pub and sub
   - con.c publish_pub should filter and expand
    - should a parallel approach be taken for gql instead of sharing?
   - publish takes object or native, converts to gqlValue, maybe just native
  - how to upgrade and get subscription in place
   - can post body be included in wb upgrade or pushed through websocket?
    - sse has to be early as it is one way
    - seems like an upgrade can be on any request type

  - example, metrics
   - subscribe to new metric
    - newMetric(namespace: String, flow: String, task: String, detail: String) Metric
     - safer or more controlled
    - newMetric(subject: String) Metric
     - simpler in some respects
    - code would Agoo::GraphQL::publish(subject, obj) where obj is a Metric object
    - both would be valid
     - call to subscribe similar as with WebSockets
      - difference is output format from event object

  - graphql_publish
   - scans all subscribers for matching keys and uses associated output spec to generate the message to send
   - want to keep ruby value out of publish
   - convert to full JSON then filter in each based on spec
   - change current subscribe to have an optional formatter/filter
   - means publishing JSON is allowed
   - pub.h add type for AGOO_PUB_GQL
    - add field to pub.h that is gqlValue
  -


- refs
  - http://www.rubydoc.info/github/rack/rack/master/file/SPEC

rdoc -t Agoo -m README.md -x "test/*" -x "example/*" -x extconf.rb
use nice -n19 perfer when on same machine

- tests
 - cd test && tests.sh
 - bin/agoo -I ext -I lib -I example -r simple /simple@Simple
  - localhost:6464/simple
 - cd example && rackup -I ../ext -I ../lib -r agoo -s agoo
  - localhost:9292
 - cd example && ruby -I ../ext -I ../lib config.rb
  - localhost:9292
 - cd example && ruby -I ../ext -I ../lib hello.rb
  - localhost:6464/hello
 - cd example/push && rackup -I ../../ext -I ../../lib -r agoo -s agoo
  - localhost:9292/websocket.html
  - localhost:9292/sse.html
 - cd example/push && ruby -I ../../ext -I ../../lib pubsub.rb
  - localhost:6464/websocket.html
  - localhost:6464/sse.html
 - cd example/push && ruby  -I ../../ext -I ../../lib push.rb
  - localhost:6464/websocket.html
  - localhost:6464/sse.html
 - cd example && ruby -I ../ext -I ../lib mem.rb
  - memory and performance with perfer
 - cd example && ruby memx.rb
  - memory and performance with perfer, multiple workers


- server log hook
 - log callback grabs gvl

- remote cluster
 - worker server
  - connect, maybe with some kind of security
  - server feeds to worker
   - as packets arrive from con
    - needs to attach a connection id to each packet
    - worker reassemples
   - or create packet on server and pick a worker to sent it to
    - maybe based on how many outstanding to that worker and most recent latency
     - multiple and pick lowest
    - packet is con id + len + request


- doesn't die
 - cd example/push && ruby  -I ../../ext -I ../../lib push.rb
  - localhost:6464/websocket.html
  - localhost:6464/sse.html
